# Задача замощения

## Системные требования

Программа тестировалась в среде
* Ubuntu 20.10 (Linux 5.8.0-50-generic x86_64 GNU/Linux)
* Python v.3.8.6
* Версии модулей см. в `requirements.txt`

## Особенности и алгоритм программы

Программа достаточно оптимальна по памяти и используемым ресурсам. В качестве основной структуры данных для манипуляций c объектами используются numpy массивы (тип элементов _int64_).

Для подбора замощения применяются _генераторы_, это также сильно экономит память, позволяет не использовать рекурсию (что может переполнить стек вызовов) и позволяет не запоминать специально состояния, а также уже рассмотренные комбинации.

Таким образом, по памяти оценка будет порядка
(сумма размерностей всех полиомино + сумма размерностей L-полиомино + размерность таблицы*(количество полиомино и L-полиомино))*8 байт. То есть `O(n)`, где `n` - количество всех полиомино и L-полиомино при константной таблице.

По сложности алгоритм в худшем случае будет пропорционален 
`(4М_1М_2)^(H_1+H_2)`. Таким образом, в общем случае будет экспоненциальная сложность. На сколько я понял из описаний в интернете, данная проблема в общем случае является `NP` сложной, так что такая оценка вполне ожидаема.

Из вариантов решения можно также предложить генетические алогоритмы, например, с использованием модулей `pyeasyga` или `DEAP`. 

## Запуск программы

1. Устанавливаем виртуальное окружение
```shell
virtualenv env
```

2. Активируем окружение
```shell
. ./env/bin/activate
```

3. Устанавливаем модули Python
```shell
pip install -r requirements.txt
```

4. Запуск
```shell
python problem
```
